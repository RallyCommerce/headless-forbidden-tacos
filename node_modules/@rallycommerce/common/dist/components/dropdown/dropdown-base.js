var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { LitElement, html, css } from 'lit';
import { customElement, property, queryAssignedElements, queryAssignedNodes } from 'lit/decorators.js';
import { fromEvent, Subject } from 'rxjs';
import { take } from 'rxjs/operators';
import { Key, DROPDOWN_ITEM_CLASS, DROPDOWN_DIVIDER_CLASS } from './util/dropdown-utils';
import { dropdownAutoClose, DropdownAutoCloseType } from './util/dropdown-autoclose';
/**
 *
 * Rally dropdown element. Must be used in conjuction with `rally-dropdown-menu-base` element.
 *
 * Example usage:
 * `
 *    <rally-dropdown-base placement="bottom-left">
 *      <button slot="dropdown-toggle">Bottom left</button>
 *      <rally-dropdown-menu-base>
 *        <button>Item 1</button>
 *        <button disabled>Item 2</button>
 *        <button>Item 3</button>
 *        <div class="dropdown-divider"></div>
 *        <div class="dropdown-item-text">Text item 4</div>
 *      </rally-dropdown-menu-base>
 *    </rally-dropdown-base>
 * `
 *
 */
let RallyDropdownBase = class RallyDropdownBase extends LitElement {
    constructor() {
        super(...arguments);
        /**
         * Indicates whether the dropdown should be closed when clicking one of dropdown items or pressing ESC.
         *
         * * `true` - the dropdown will close on both outside and inside (menu) clicks.
         * * `false` - the dropdown can only be closed manually via `isOpen` property.
         * * `"inside"` - the dropdown will close on inside menu clicks, but not outside clicks.
         * * `"outside"` - the dropdown will close only on the outside clicks and not on menu clicks.
         *
         * Default value is "outside".
         */
        this.autoClose = DropdownAutoCloseType.Outside;
        this.isMenuOpen = false;
        /**
         * The placement of the dropdown.
         *
         * Possible values:
         * "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right", "left", "left-top", "left-bottom", "right", "right-top", "right-bottom".
         *
         * Default value is "bottom".
         *
         */
        this.placement = 'bottom';
        this.destroyCloseHandlers$ = new Subject();
    }
    /**
     * Defines whether or not the dropdown menu is opened initially.
     */
    set isOpen(value) {
        this.isMenuOpen = value;
        this.setDropdownMenuAttribute('isOpen', value.toString());
        this.setDropdownToggleAriaAttributes();
    }
    get isOpen() {
        return this.isMenuOpen;
    }
    get menu() {
        var _a;
        return (_a = this.rlDropdownMenu) === null || _a === void 0 ? void 0 : _a[0];
    }
    get anchor() {
        var _a;
        return (_a = this.dropdownToggle) === null || _a === void 0 ? void 0 : _a[0];
    }
    get menuItems() {
        var _a;
        return Array.from(((_a = this.menu) === null || _a === void 0 ? void 0 : _a.querySelectorAll(`.${DROPDOWN_ITEM_CLASS}`)) || []);
    }
    render() {
        return html `
      <slot name="dropdown-toggle" class="dropdown-toggle" @click="${this.toggle}" @keydown="${this.onKeyDown}"></slot>
      <slot @dropdownKeyDown="${this.onMenuKeyDown}"></slot>
    `;
    }
    firstUpdated() {
        this.applyPlacementClasses();
        this.setDropdownToggleAriaAttributes();
        if (this.isOpen) {
            this.setCloseHandlers();
        }
        setTimeout(() => {
            this.setDropdownMenuAttribute('isOpen', this.isOpen.toString());
            this.setDropdownMenuAttribute('placement', this.placement);
        });
    }
    disconnectedCallback() {
        this.destroyCloseHandlers$.next(); // destroy any existing close handlers
    }
    /**
     * Opens the dropdown menu.
     */
    open() {
        var _a;
        if (!this.isOpen) {
            this.isOpen = true;
            this.applyCustomDropdownClass(this.dropdownClass);
            this.applyPlacementClasses();
            this.setCloseHandlers();
            (_a = this.anchor) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }
    /**
     * Sets the close handlers for the dropdown menu.
     */
    setCloseHandlers() {
        this.destroyCloseHandlers$.next(); // destroy any existing close handlers
        dropdownAutoClose(document, this.autoClose, (source) => {
            var _a;
            this.close();
            if (source === 0 /* ESCAPE */) {
                (_a = this.anchor) === null || _a === void 0 ? void 0 : _a.focus();
            }
        }, this.destroyCloseHandlers$, this.menu ? [this.menu] : [], this.anchor ? [this.anchor] : [], `.${DROPDOWN_ITEM_CLASS},.${DROPDOWN_DIVIDER_CLASS}`);
    }
    /**
     * Closes the dropdown menu.
     */
    close() {
        if (this.isOpen) {
            this.isOpen = false;
            this.destroyCloseHandlers$.next();
        }
    }
    /**
     * Toggles the dropdown menu.
     */
    toggle() {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Handles `keydown` event on the dropdown menu element.
     * @param customEvent
     */
    onMenuKeyDown(customEvent) {
        const originalEvent = customEvent.detail;
        this.onKeyDown(originalEvent);
    }
    /**
     * Handles `keydown` event on the dropdown element.
     * @param customEvent
     */
    onKeyDown(event) {
        var _a;
        /* eslint-disable-next-line deprecation/deprecation */
        const key = event.which;
        const itemElements = this.getMenuElements();
        let position = -1;
        let itemElement = null;
        const isEventFromToggle = this.isEventFromToggle(event);
        if (!isEventFromToggle && itemElements.length) {
            itemElements.forEach((item, index) => {
                if (item.contains(event.target)) {
                    itemElement = item;
                }
                if (item === document.activeElement) {
                    position = index;
                }
            });
        }
        // closing on Enter / Space
        if (key === Key.Space || key === Key.Enter) {
            if (itemElement && (this.autoClose === true || this.autoClose === DropdownAutoCloseType.Inside)) {
                // Item is either a button or a link, so click will be triggered by the browser on Enter or Space.
                // So we have to register a one-time click handler that will fire after any user defined click handlers
                // to close the dropdown
                fromEvent(itemElement, 'click').pipe(take(1)).subscribe(() => this.close());
            }
            return;
        }
        if (key === Key.Tab) {
            if (event.target && this.isOpen && this.autoClose) {
                if (this.anchor === event.target) {
                    if (event.shiftKey) {
                        this.close();
                    }
                    return;
                }
                else {
                    fromEvent(event.target, 'focusout').pipe(take(1)).subscribe(({ relatedTarget }) => {
                        if (!this.contains(relatedTarget)) {
                            this.close();
                        }
                    });
                }
            }
            return;
        }
        // opening / navigating
        if ([Key.ArrowDown, Key.ArrowUp, Key.Home, Key.End].includes(key)) {
            if (isEventFromToggle || itemElement) {
                this.open();
                if (itemElements.length) {
                    switch (key) {
                        case Key.ArrowDown:
                            position = Math.min(position + 1, itemElements.length - 1);
                            break;
                        case Key.ArrowUp:
                            if (this.isDropup() && position === -1) {
                                position = itemElements.length - 1;
                                break;
                            }
                            position = Math.max(position - 1, 0);
                            break;
                        case Key.Home:
                            position = 0;
                            break;
                        case Key.End:
                            position = itemElements.length - 1;
                            break;
                    }
                    (_a = itemElements[position]) === null || _a === void 0 ? void 0 : _a.focus();
                }
                event.preventDefault();
            }
        }
    }
    isDropup() { return this.classList.contains('dropup'); }
    isEventFromToggle(event) {
        var _a;
        return (_a = this.anchor) === null || _a === void 0 ? void 0 : _a.contains(event.target);
    }
    getMenuElements() {
        return this.menuItems.filter((item) => !item.disabled);
    }
    /**
     * Applies a custom class to the dropdown element.
     * @param newClass
     * @param oldClass
     */
    applyCustomDropdownClass(newClass, oldClass) {
        if (oldClass) {
            this.classList.remove(oldClass);
        }
        if (newClass) {
            this.classList.add(newClass);
        }
    }
    /**
     * Applies placement classes to the dropdown element.
     */
    applyPlacementClasses() {
        var _a;
        // remove the current placement classes
        this.classList.remove('dropup');
        this.classList.remove('dropdown');
        /*
        * apply the new placement
        * in case of top use up-arrow or down-arrow otherwise
        */
        const dropdownClass = ((_a = this.placement) === null || _a === void 0 ? void 0 : _a.search('^top')) !== -1 ? 'dropup' : 'dropdown';
        this.classList.add(dropdownClass);
    }
    setDropdownMenuAttribute(attribute, value) {
        var _a;
        (_a = this.menu) === null || _a === void 0 ? void 0 : _a.setAttribute(attribute, value);
    }
    setDropdownToggleAriaAttributes() {
        var _a;
        const dropdownToggleNode = (_a = this.dropdownToggleNode) === null || _a === void 0 ? void 0 : _a[0];
        dropdownToggleNode === null || dropdownToggleNode === void 0 ? void 0 : dropdownToggleNode.setAttribute('aria-expanded', this.isOpen.toString());
    }
};
RallyDropdownBase.styles = css `
  :host {
    display: inline-block;
  }

  :host(.dropup),
  :host(.dropdown) {
    position: relative;
  }

  .dropdown-toggle::slotted(*) {
    white-space: nowrap;
  }
  .dropdown-toggle::slotted(*)::after {
    display: inline-block;
    margin-left: 0.255em;
    vertical-align: 0.255em;
    content: "";
    border-top: 0.3em solid;
    border-right: 0.3em solid transparent;
    border-bottom: 0;
    border-left: 0.3em solid transparent;
  }
  .dropdown-toggle::slotted(*):empty::after {
    margin-left: 0;
  }

  :host(.dropup) .dropdown-toggle::slotted(*)::after {
    display: inline-block;
    margin-left: 0.255em;
    vertical-align: 0.255em;
    content: "";
    border-top: 0;
    border-right: 0.3em solid transparent;
    border-bottom: 0.3em solid;
    border-left: 0.3em solid transparent;
  }
  :host(.dropup) .dropdown-toggle::slotted(*):empty::after {
    margin-left: 0;
  }
  `;
__decorate([
    property()
], RallyDropdownBase.prototype, "autoClose", void 0);
__decorate([
    property({ type: String })
], RallyDropdownBase.prototype, "dropdownClass", void 0);
__decorate([
    property({ type: Boolean })
], RallyDropdownBase.prototype, "isOpen", null);
__decorate([
    property()
], RallyDropdownBase.prototype, "placement", void 0);
__decorate([
    queryAssignedElements({ slot: 'dropdown-toggle' })
], RallyDropdownBase.prototype, "dropdownToggle", void 0);
__decorate([
    queryAssignedNodes({ slot: 'dropdown-toggle', flatten: true })
], RallyDropdownBase.prototype, "dropdownToggleNode", void 0);
__decorate([
    queryAssignedElements({ selector: 'rally-dropdown-menu-base' })
], RallyDropdownBase.prototype, "rlDropdownMenu", void 0);
RallyDropdownBase = __decorate([
    customElement('rally-dropdown-base')
], RallyDropdownBase);
export { RallyDropdownBase };
//# sourceMappingURL=dropdown-base.js.map