import deepmerge from 'deepmerge';
export function areEqual(first, second, ignoreProperties = [], compareProperties = []) {
    if (first === second) {
        return true;
    }
    if (typeof first !== 'object' || typeof second !== 'object' || first === null || second === null) {
        return false;
    }
    const keysA = Object.keys(first).filter(key => !ignoreProperties.includes(key)).filter((key) => compareProperties.length > 0 ? compareProperties.includes(key) : true);
    const keysB = Object.keys(second).filter(key => !ignoreProperties.includes(key)).filter((key) => compareProperties.length > 0 ? compareProperties.includes(key) : true);
    if (keysA.length !== keysB.length) {
        return false;
    }
    for (const key of keysA) {
        if (!keysB.includes(key)) {
            return false;
        }
        if (typeof first[key] === 'function' || typeof second[key] === 'function') {
            if (first[key].toString() !== second[key].toString()) {
                return false;
            }
        }
        else {
            if (!areEqual(first[key], second[key])) {
                return false;
            }
        }
    }
    return true;
}
export function merge(target, source, useCustomMerge = true) {
    if (typeof source !== 'object' || source === null) {
        return source;
    }
    return deepmerge(target, source, { arrayMerge: combineMerge, isMergeableObject: isPlainObject, customMerge: useCustomMerge ? customMerge : undefined });
}
const combineMerge = (target, source, options) => {
    const destination = target === null || target === void 0 ? void 0 : target.slice();
    source === null || source === void 0 ? void 0 : source.forEach((item, index) => {
        if (typeof destination[index] === 'undefined') {
            destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);
        }
        else if (options.isMergeableObject(item)) {
            destination[index] = deepmerge(target[index], item, options);
        }
        else if (target.indexOf(item) === -1) {
            destination.push(item);
        }
    });
    return destination;
};
const isPlainObject = (object) => {
    if (Object.prototype.toString.call(object) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(object);
    return prototype === null || prototype === Object.prototype;
};
const customMerge = (key, options) => {
    if (key === 'validators') {
        return mergeValidators;
    }
    return undefined;
};
export const mergeValidators = (target, source, options) => {
    const targetCustomValidators = target.customValidators || [];
    const sourceCustomValidators = source.customValidators || [];
    delete target.customValidators;
    delete source.customValidators;
    const mergedValidators = deepmerge(target, source, options);
    mergedValidators.customValidators = [
        ...(targetCustomValidators || []),
        ...(sourceCustomValidators || [])
    ];
    return mergedValidators;
};
const existingIds = [];
export function generateUniqueId(prefix = 'rally-') {
    const newId = crypto.getRandomValues(new Uint32Array(1))[0].toString(32);
    if (existingIds.includes(newId)) {
        return generateUniqueId(prefix);
    }
    existingIds.push(newId);
    return prefix + newId;
}
const setTimeoutWrapper = (fn, delay) => {
    setTimeout(fn, delay);
};
export const runOnNextTick = (fn) => { setTimeoutWrapper(fn, 0); };
export const runWithDelay = (fn, delay) => { setTimeoutWrapper(fn, delay); };
export function objectPropertiesToArray(myObj) {
    return Object.keys(myObj).filter(key => myObj.hasOwnProperty(key)).map(key => myObj[key]);
}
export function objectKeysToArray(myObj) {
    return Object.keys(myObj).filter(key => myObj.hasOwnProperty(key)).map(key => key);
}
export function replaceWith(str, type, char = '_') {
    if (type === Convert.CamelCase) {
        const regex = new RegExp(`(${char}[a-z])`, 'g');
        str = str.replace(regex, (match) => match.toUpperCase().replace(char, ''));
    }
    else {
        str = str.replace(/([a-z])([A-Z])/g, `$1${char}$2`).toLowerCase();
    }
    return str;
}
function convertToObject(obj, type) {
    if (!obj) {
        return;
    }
    if (typeof obj !== 'object') {
        return obj;
    }
    return Object.keys(obj).reduce((newObj, key) => {
        const newKey = replaceWith(key, type);
        if (obj[key] instanceof Array) {
            newObj[newKey] = obj[key].map(item => convertTo(item, type));
        }
        else if (obj[key] instanceof Object) {
            newObj[newKey] = convertTo(obj[key], type);
        }
        else {
            newObj[newKey] = obj[key];
        }
        return newObj;
    }, {});
}
export function convertTo(obj, type = Convert.CamelCase) {
    if (!obj) {
        return;
    }
    if (typeof obj !== 'object') {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map((item) => convertToObject(item, type));
    }
    else {
        return convertToObject(obj, type);
    }
}
export function reverseString(initialString = '') {
    return initialString.split('').reverse().join('');
}
export function getFormattedAmountWithCurrency(value, currencyConfig, showCurrencyCode = false, excludeDecimalDigits = false, suffix = '') {
    var _a;
    let formattedAmountWithCurrency = '';
    if (value === null) {
        formattedAmountWithCurrency = (currencyConfig === null || currencyConfig === void 0 ? void 0 : currencyConfig.symbolPosition) === 'before' ? (currencyConfig === null || currencyConfig === void 0 ? void 0 : currencyConfig.symbol) + '--' : '--' + (currencyConfig === null || currencyConfig === void 0 ? void 0 : currencyConfig.symbol);
    }
    else {
        if (typeof value !== 'number') {
            value = Number.parseFloat(value);
        }
        if (!Number.isNaN(value)) {
            const [integer, decimal] = value.toFixed(currencyConfig === null || currencyConfig === void 0 ? void 0 : currencyConfig.decimalDigits).split('.');
            let formattedInteger = (_a = reverseString(integer).match(new RegExp('.{1,3}', 'g'))) === null || _a === void 0 ? void 0 : _a.join(currencyConfig === null || currencyConfig === void 0 ? void 0 : currencyConfig.thousandsSeparator);
            formattedInteger = reverseString(formattedInteger);
            const formattedAmount = excludeDecimalDigits ? (formattedInteger + suffix) : (formattedInteger + (currencyConfig === null || currencyConfig === void 0 ? void 0 : currencyConfig.decimalSeparator) + decimal);
            formattedAmountWithCurrency = (currencyConfig === null || currencyConfig === void 0 ? void 0 : currencyConfig.symbolPosition) === 'before' ?
                (currencyConfig === null || currencyConfig === void 0 ? void 0 : currencyConfig.symbol) + formattedAmount :
                formattedAmount + (currencyConfig === null || currencyConfig === void 0 ? void 0 : currencyConfig.symbol);
        }
    }
    return showCurrencyCode ? formattedAmountWithCurrency + ' ' + (currencyConfig === null || currencyConfig === void 0 ? void 0 : currencyConfig.code) : formattedAmountWithCurrency;
}
export var Convert;
(function (Convert) {
    Convert["Underscore"] = "underscore";
    Convert["CamelCase"] = "camelCase";
})(Convert || (Convert = {}));
//# sourceMappingURL=utils.js.map